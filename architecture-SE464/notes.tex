\documentclass{article}
\usepackage{parskip}
\usepackage[margin=.6in]{geometry}
\begin{document}

\section*{Lecture 4} % (fold)
\label{sec:lecture_4}
\textbf{Functional requirements} - requirements that are concerned with what the system should do/how it should behave

\textbf{Quality Requirements} - requirements that are concerned with how well the system supports functionalities

\paragraph{Modifiability} % (fold)
\label{par:modifiability}
is  a quality attribute that is more concerned with ``fitness for future'' as opposed to ``fitness for purpose'' like functionality, performance, reliability and security. Think of modifiability as the foundation for balancing the other qualities. Often \textbf{maintainability} is used to describe this as well. A \textbf{module implementation} is the secrets hidden in the module.The \textbf{axiom of independence} states that a specific module can be adjusted to satisfy its requirement without effecting other requirements.
% paragraph modifiability (end)

\paragraph{Modularity} % (fold)
\label{par:modularity}
is the key to achieving modifiability. A \textbf{module} is an unit of the system with a defined purpose and interface. They allow:
\begin{itemize}
    \item better understanding of system pieces
    \item parallel development
    \item evolution by hiding implementation details (limits ripples of changes)
    \item independent compilation
\end{itemize}

\paragraph{Interfaces} % (fold)
\label{par:interfaces}
are contracts between modules and their environments. Interfaces should be based on abstractions that are unlikely to change (shit gets crazy when interfaces change). A \textbf{provided interface} tells what services the module provides its environment. A \textbf{required interface} tells what services the module requires of its environment. A \textbf{syntactic interface} specifies how to invoke a modules provided services (usually in class declarations). A \textbf{semantic interface} specifies how a module behaves (usually in comments).
%paragraph modularity (end)

\paragraph{Organization} % (fold)
\label{par:organization}
Smaller simpler modules are usually preferred wince they will use less dependencies. These are also easier to implement and maintain. Often large systems are modularized into a hierarchy so that we can make larger modules out of smaller ones. Keep your mappings of module names in the hierarchy simple. \textbf{Crosscutting} is when a module has dependencies at different levels of the hierarchy which can get confusing. \textbf{Tangling} is when a module satisfies requirements across the hierarchy. Try to avoid these.
% paragraph organization (end)

\paragraph{Analysis} % (fold)
\label{par:analysis}
of modifiability can be improved by increasing coupling (clearer rules, more abstraction of common services, localize changes), or by decreasing coupling(reduce ripple effects, no globals, dependency injection)
% paragraph analysis (end)

%section lecture_4 (end)


\section*{Lecture 5} % (fold)
\label{sec:lecture_5}
\textbf{Cohesion} is a measure of the coherence of a module amongst its other pieces (GOOD).

\textbf{Coupling} is the degree of relatedness between modules (BAD).

\paragraph{Good Cohesion} % (fold)
\label{par:good_cohesion}
means that each module has a clear purpose (responsibility). Modules gather like purposed operations and classes. A good design has clear rules where to put new code during its evolution. Good cohesion happens when there is a clear purpose for each module, function are related by topic or interaction, and modules are abstractions.
% paragraph good_cohesion (end)


\paragraph{Bad Cohesion} % (fold)
\label{par:bad_cohesion}
happens through:
\begin{itemize}
    \item  coincidental cohesion - when code is put in a random module (can happen when design is not clear)
    \item  god classes - when a class has too many responsibilities, often has non communicating behaviors(functions that share no data or results)
    \item  control flow cohesion - when code is merged into a single module to share common flow
    \item  and temporal cohesion.all operation executed at a similar point in time into a module (leads to duplication, and complicated logic)
\end{itemize}

% paragraph bad_cohesion (end)

\paragraph{Coupling} % (fold)
\label{par:coupling}
happens due to different types of dependencies:
\begin{itemize}
    \item data - A provides data to B
    \item control - A controls execution of B
    \item service - A calls a service in B
    \item identity - A knows of target module B
    \item location - A knows the location of target module B
    \item quality of service - A expects certain quality of service from B
    \item content - A includes code from B
\end{itemize}
You can minimize coupling by minimizing the number of dependencies among modules (dependencies within module is fine) or minimizing the strength of the dependencies (data is weakest). Its OK to have more dependencies on stable interfaces, but frequent interface changes should have less dependencies.
% paragraph coupling (end)

\paragraph{High Coupling} % (fold)
\label{par:high_coupling}
is bad. Hidden coupling is even worse, everything should be explicit and in interfaces (I'm looking at you JavaScript). This can be caused by mutable globals and reflection. \textbf{Implementation inheritance} causes strong coupling and lacks a clear interface, inheriting interfaces is much more desirable since it doesnt suffer the ``fragile base class'' problem (base class can break everything). \textbf{Control coupling} occurs when one module controls execution flow of another usually through flags, should try to use polymorphism instead. \textbf{Stamp coupling} occurs when more data is passed to a module than is necessary, it introduces more dependency than is needed.
% paragraph high_coupling (end)

% section lecture_5 (end)

\section*{Lecture 6} % (fold)
\label{sec:lecture_6}
\paragraph{Refactoring}
\label{par:refactoring}
is improving design without changing functionality.
% paragraph refactoring (end)

\paragraph{Technical Debt and Incremental Design} % (fold)
\label{par:technical_debt_and_incremental_design}
\textbf{Incremental Design} is looking at refactoring anytime anything new is added or fixed. By frequently refactoring to avoid building up design problems which lead to architectural erosion. \textbf{Technical debt} is the accumulation of design problems anytime something new is added without refactoring. Better to floss every night than have to get a root canal.
% paragraph technical_debt_and_incremental_design (end)

\paragraph{Test Drive Design} % (fold)
\label{par:test_drive_design}
is writing tests for a design before you start coding. Refactoring requires a comprehensive test suite to make sure you don't introduce new bugs. Tests should be written based on the requirements so they capture what should happen. Tests can also help flush out a design or interface.
% paragraph test_drive_design (end)

\paragraph{Code Smells} % (fold)
\label{par:code_smells}
indicate possible design problems, usually they trigger a refactor.

\textbf{Duplicated Code}:
\begin{itemize}
    \item Disadvantages
    \begin{itemize}
        \item parallel maintenance - must propagate changes to multiple places
        \item increases the amount of code to be maintained
    \end{itemize}
    \item Advantages
    \begin{itemize}
        \item independent development - evolve code in multiple different directions without breaking other's work
        \item simplify things - clone can be specialized for target use making it complicated to refactor
        \item increase performance - optimized for specific uses
        \item no coupling
    \end{itemize}
    \item Ways to reduce:
    \begin{itemize}
        \item extract method - pullout duplicated code into shared method
        \item extract class - make new common class to be inherited from
        \item template method
    \end{itemize}
\end{itemize}
% paragraph code_smells (end)

% section lecture_6 (end)

\section*{Lecture 7} % (fold)
\label{sec:lecture_7}

\paragraph{Long Method} % (fold)
\label{par:long_method}
Methods that are too long should usually be factored out into smaller methods called the compose methods.
% paragraph long_method (end)

\paragraph{Large Class} % (fold)
\label{par:large_class}
A class that has too many methods likely has too many responsibilities. Break it up into smaller classes or push parts of code into attributes. Some exceptions:
\begin{itemize}
    \item math utility classes - just a group of functions and not really OOP
    \item library classes - cater to more usage context
    \item monitors - needs operations for all controllers
    \item constructor methods - may need many of these, they don't count to a classes method count
\end{itemize}
% paragraph large_class (end)

\paragraph{Comments} % (fold)
\label{par:comments}
Comments inside methods imply opaque implementations. You should refactor the code to make it more self-evident.
% paragraph comments (end)

\paragraph{Switch Statement} % (fold)
\label{par:switch_statement}
These should usually be replaced with polymorphism. If you are dealing with data type you can used pattern matching. Anytime a new subtype is added you have to go edit every switch statement where it is used and recompile every subtype.
% paragraph switch_statement (end)

\paragraph{Primitive Obsession} % (fold)
\label{par:primitive_obsession}
This is when a developer tries to manipulate primitives to serve a purpose where a custom class would be better suited. This way we can encapsulate related functions and expand much more easily in the future.
% paragraph primitive_obsession (end)

\paragraph{Long Parameter List} % (fold)
\label{par:long_parameter_list}
This makes it difficult for clients to understand. Can be caused by:
\begin{itemize}
    \item a method having too many responsibilities -  break it into subtasks
    \item method is operating on data that doesn't belong to it - move method to be with data owner
    \item method takes too many disparate member variables - gather parameters into an object
\end{itemize}
% paragraph long_parameter_list (end)

\paragraph{Feature Envy} % (fold)
\label{par:feature_envy}
This is where a mthod is more interested in another class and should be moved into that class.
% paragraph feature_envy (end)

\paragraph{Data Clumps} % (fold)
\label{par:data_clumps}
This is where a set of variables hang out together alot (are frequently passed as parameters together, or accessed at the same time), so they should be encapsulated together into an object.
% paragraph data_clumps (end)

\paragraph{Shotgun Surgery} % (fold)
\label{par:shotgun_surgery}
This is when a single change requires tones of changes to other unrelated things. These changes should be localized into one thing.
% paragraph shotgun_surgery (end)

\paragraph{Direct Constructor Call} % (fold)
\label{par:direct_constructor_call}
This often leads to brittleness. Calls to constructor go wonky when subclasses get involved so you should use a factory method instead.
% paragraph direct_constructor_call (end)

\paragraph{Speculative Generality} % (fold)
\label{par:speculative_generality}
This is when code is extended with shit because you might need it someday. This is bad as things will get complex for no reason at all. Instead you should add things when they are needed and evolve the design as required.
% paragraph speculative_generality (end)
% section lecture_7 (end)

\section*{Lecture 8} % (fold)
\label{sec:lecture_8}
A design patter is a solution to a re-occurring design pattern (used at least 3 different systems). These are ways to package pieces of reusable design knowledge. They usually consist of:
\begin{itemize}
    \item design context and problem
    \item design solution
    \begin{itemize}
        \item structural part made of elements and their roles and relationships/interactions
        \item usually a UML
    \end{itemize}
    \item design consequences
    \begin{itemize}
        \item impacts on system qualities
        \item implementation alternatives
    \end{itemize}
    \item examples
\end{itemize}

If a pattern relies of language specific constructs it is called a \textbf{idiom}.

\paragraph{Composite Pattern} % (fold)
\label{par:composite_pattern}
Create a common interface for all elements (no matter their place in the hierarchy) so that all elements and their compositions can be treated the same. Basically we want to treat all individual objects and multiple recursively composed objects exactly the same. You want a component class that has operations used by individuals and collections, then you have a leaf class and composite class that inherit from it.
% paragraph composite_pattern (end)

\paragraph{Decorator Pattern} % (fold)
\label{par:decorator_pattern}
This is used when we want the ability to augment object with new responsibilities without creating a subclass. Basically you have an interface with a subclass for core functionality and a decorator subclass that contains an instance, which your concrete object class inherits from. The functions in the decorator class calls the same function on its instance which will then call the correct function from one of its subclasses. This function will add some functionality then call its super class function (defined in core functionalty class).
% paragraph decorator_pattern (end)

% section lecture_8 (end)

\section*{Lecture 9} % (fold)
\label{sec:lecture_9}
\paragraph{Interpreter Pattern} % (fold)
\label{par:interpreter_pattern}
This provides a way to translate a language grammar into an object structure so that operations can be implemented. It has a abstract class for an expression (something composed of more specific parts combined) and from that class you have a subclass for terminal expressions and nonterminal expressions. All of these classes have some function for interpreting them that is called down the tree recursively.
% paragraph interpretor_pattern (end)

\paragraph{Visitor Pattern} % (fold)
\label{par:visitor_pattern}
This encapsulates operations on the object structure into object so that you can easily add new operations without disturbing the classes implementing the object structure. A visitor is an object encasing an operation. Visitors visit elements of the structure on which they operate through a common interface. Elements have a accept function that calls the visitors visit function for this element (ie the dog class would call visitor.visitDog(this)).
% paragraph visitor_pattern (end)


\textbf{Other Patterns}
\begin{itemize}
    \item Composite
    \begin{itemize}
        \item Understand UML composition (black diamond), including its semantics (no sharing, no cycles, nested life span), allowed multiplicities on the diamond, and the shape of the corresponding object diagrams.
        \item Understand the tradeoff between uniform interface for leaf and composite vs. navigation and editing logic in composite only.
    \end{itemize}
    \item Decorator
    \begin{itemize}
        \item Be able to apply decorator to extend design generated by composite.
        \item Understand the issue of split identity.
    \end{itemize}
    \item Adapter
    \begin{itemize}
        \item Understand the difference between adapter and decorator. Hint: think about what each pattern does to the interface of the wrapee.
    \end{itemize}
    \item Interpreter
    \begin{itemize}
        \item Understand that interpreter builds on composite.
    \end{itemize}
    \item Visitor
    \begin{itemize}
        \item Understand how double dispatching occurs.
        \item Understand the interface of the visit methods.
        \item Understand how visitors are unnecessary in functional programming (replaced by pattern matching).
        \item Understand when to use visitor and when interpreter.
    \end{itemize}
    \item Singleton
    \begin{itemize}
        \item Understand the issue of a singleton being global state and the consequences (potential side effects, concurrent access).
    \end{itemize}
    \item Factory
    \begin{itemize}
        \item Understand the difference between abstract factory and factory method.
    \end{itemize}
    \item Strategy
    \begin{itemize}
        \item Understand how strategy supports dynamic reconfiguration thanks to
        object composition.
    \end{itemize}
    \item Template Method
    \begin{itemize}
        \item Understand how to vary steps in template method subclass.
        \item Understand the fragile base class problem and why object composition and interfaces are often a better alternative.
    \end{itemize}
    \item Iterator
    \begin{itemize}
        \item What does iterator encapsulate?
        \item What is the difference between iterator vs. visitor? Hint: what is that each pattern encapsulates?
    \end{itemize}
    \item Observer
    \begin{itemize}
        \item Understand implementation variants to access subject's data: getting full update vs. selective registration and update.
    \end{itemize}
\end{itemize}
% section lecture_9 (end)

\section*{Lecture 10} % (fold)
\label{sec:lecture_10}
An architecure pattern is a solution to a re-occuring architectureal problem (same def as design pattern).

It follows the same pattern as design patterns:
\begin{itemize}
    \item problem description
    \item solution
    \begin{itemize}
         \item structures
         \begin{itemize}
             \item component types
             \item connector types
             \item topology - contraints on how things are connected
         \end{itemize}
         \item interactions
     \end{itemize}
    \item consequences
\end{itemize}

\subsection*{Layered Architecture} % (fold)
\label{sub:layered_architecture}
Each layer is a different level of abstraction. A layer provides for the layer above it an relies on the layer below it. Can be represented as a stack or onion layers.

Structures:
\begin{itemize}
    \item components
    \begin{itemize}
        \item modules
        \item interfaces
    \end{itemize}
    \item connectors
    \begin{itemize}
        \item function calls and callbacks
        \item messages
        \item queries
        \item etc
    \end{itemize}
    \item topology
    \begin{itemize}
        \item hierarchy
        \item pure form - communications between adjacent layers only
    \end{itemize}
\end{itemize}

A \textbf{hierarchy} topology allows layers to talk up an down a complicated tree of relationships. A \textbf{pure form} allows only adjacent layers to talk to each other.

Advantages of pure style:
\begin{itemize}
    \item better abstraction - layers can directly build on each other
    \item portability - you can swap out lower layers easily
\end{itemize}
Disadvantages of pure style:
\begin{itemize}
    \item performance - we have to communicate through layers
    \item limited functionality
\end{itemize}

We often use a hybrid called \textbf{cross-layer} which allows layers to be oddly shaped to give them access to layers above and blow them in different fashions.

Dependencies should really only run down. Having low layers rely on high layers can make things unstable quickly.

\paragraph{Exception handling} % (fold)
\label{par:exception_handling}
Exeptions need to bubble up through the layers when they are not properly handled. Ideally an exception should be handled in the same layer it is raised in (that is where the necessary data is, upper layers may not be expecting it, and passing shit increases coupling).
% paragraph exception_handling (end)

Consequences:
\begin{itemize}
    \item advantages
    \begin{itemize}
        \item better understand system by extraction
        \item insulation from changes in lower levels
        \item levels can be swapped out
    \end{itemize}
    \item disadvantages
    \begin{itemize}
        \item performance problems
        \item not suitable for all systems
    \end{itemize}
\end{itemize}

Tiered architectures and interpreters are special forms of layered architecture
% subsection layered_architecture (end)

\subsection*{Interpreters} % (fold)
\label{sub:interpreters}
These are often used when executing computer programs and are subject to similar consequences as layered architectures. A virtual machine is a special kind of interpreter to convert stuff. These have something called a \textbf{hypervisor} that handles the set up and tear down of the VM.
% subsection interpreters (end)

\subsection*{Tiered Architecture} % (fold)
\label{sub:tiered_architecture}
These are layered architectures that are often used in enterprise systems.

Broken up into tier layers:
\begin{itemize}
    \item data management
    \item business logic
    \item presentation
\end{itemize}

Often data management and business logic are combined into one tier making it a two tier system. We really like to decouple the UI from basically everything else because it has a difference audience and different triggers

Some design patterns used:
\begin{itemize}
    \item domain logic
    \begin{itemize}
        \item transaction script
        \item table module
        \item domain model
        \item service layer
    \end{itemize}
    \item Data source
    \begin{itemize}
        \item table data gateway
        \item row data gateway
        \item active record
        \item data mapper
    \end{itemize}
\end{itemize}

You can break things up into as many tier as you want, but shit with similar functionality needs to be coupled and you need a concrete order of tiers.
% subsection tiered_architecture (end)
% section lecture_10 (end)

\section*{Lecture 11} % (fold)
\label{sec:lecture_11}
\subsection*{Call and Return Architecture} % (fold)
\label{sub:call_and_return_architecture}
These are the architectures standard in code (main program, abstract classes, OO, functional).

Main program Architecture:
\begin{itemize}
    \item hierarchy - decomposition into subroutines
    \item components - procedures
    \item connectors - procedure calls
\end{itemize}

Abstract classes Architecture:
\begin{itemize}
    \item data structures abstracted into set of operations
    \item components - ADTs
    \item connectors - function calls and messages
\end{itemize}

Object Oriented Architecture:
\begin{itemize}
    \item ADTs with inheritance and polymorphism
    \item strengths
    \begin{itemize}
        \item domain modeling
        \item abstract problems are easier to understand
        \item interfaces and hierarchies
    \end{itemize}
    \item weaknesses
    \begin{itemize}
        \item high coupling
        \item side-effects
        \item complex interactions
    \end{itemize}
\end{itemize}

Functional Programming Architecture:
\begin{itemize}
    \item Purity = immutable data
\end{itemize}
% subsection call_and_return_architecture (end)
\subsection*{Interacting Processes} % (fold)
\label{sub:interacting_processes}
Structure:
\begin{itemize}
    \item components
    \begin{itemize}
        \item lightweight processes (preemptive threads, cooperative coroutines)
        \item heavyweight processes (OS processes)
    \end{itemize}
    \item connectors
    \begin{itemize}
        \item shared variables
        \item messages
        \item events
        \item co-routine
    \end{itemize}
\end{itemize}

\paragraph{OS Processes} % (fold)
\label{par:os_processes}
are much more costly than lightweight processes but can be used to build reliable systems as they provide memory protection and can restart other processes selectively.
% paragraph os_processes (end)

\paragraph{Concurrent State Machines} % (fold)
\label{par:concurrent_state_machines}
\begin{itemize}
    \item components - state machines executing concurrently
    \item connectors
    \begin{itemize}
        \item message queues
        \item shared variables
    \end{itemize}
\end{itemize}
% paragraph concurrent_state_machines (end)
% subsection interacting_processes (end)

\subsection*{Implicit Invocation} % (fold)
\label{sub:implicit_invocation}
Instead of the standard invoking a procedure directly, we now call it through events and listeners. Systems built around implicit invocation are called \textbf{Publish-Subscribe Systems}.
\begin{itemize}
    \item components - modules with interfaces providing operations and events
    \item connectors
    \begin{itemize}
        \item binding between event broadcast and calls
        \item direct operation calls
    \end{itemize}
\end{itemize}
A component registers its interest in an event by binding a procedure to it. The announcer of events do not know which component will be affected by the event. Components cannot make assumptions about the order they will be processed in or what will happen as a result of their event (treat events like concurrent threads).

\paragraph{Message Broker} % (fold)
\label{par:message_broker}
This is also known as an event bus. It stores messages and forwards them to the correct place allowing persistent and transactional messaging. Often used for enterprise application integration.
% paragraph message_broker (end)

\paragraph{Data Distribution Service} % (fold)
\label{par:data_distrubution_service}
This has direct forwarding with no storage of events. Due to this data sources have metadata describing the quality of the service. This is usually used for real-time information exchange.
% paragraph data_distrubution_service (end)
strengths
\begin{itemize}
    \item extensibility - add new features by registering them for events
    \item loose coupling -  add and replace components without affecting each other by registering or unregistering
\end{itemize}
Weaknesses:
\begin{itemize}
    \item Loss of control - components have no idea what effect they will have by announcing an event, we cannot rely on order of execution, we don't know when things are done executing
    \item Difficult to debug - same reasons as above
\end{itemize}
% subsection implicit_invocation (end)
An example of this is the MVC structure used often in UI as the model uses implicitly invocation to update the view:
\begin{itemize}
    \item Model - contains core functionality of data
    \item view - interface for displaying data
    \item controller - handle user input
\end{itemize}

% section lecture_11 (end)

\section*{Lecture 12} % (fold)
\label{sec:lecture_12}
\subsection*{Data Centric Architectures} % (fold)
\label{sub:data_centric_architectures}
These are architectures organized around a data repository, so structure of data and data management are very important.

\paragraph{Transactional Database Applications} % (fold)
\label{par:transactional_database_applications}
These are the database portion of the three tiered architecture. Concurrency is often used to speed up these systems but this causes some problems. Updates can be lost or reads can get trampled. Liveness is also an issue as things can get deadlocked or starved. First there is a request from the outside world it goes through the session which is basically the long running interaction between the client and server (usually has some form of authentication). From there the transactions are grouped together so that sever similar requests are treated the same for efficiency sake. Transactions can be groups of requests from the user to an application (\textbf{business transaction}) or from an application to the database (\textbf{system transactions}).
% paragraph transactional_database_applications (end)

\paragraph{Approaches to Concurrency} % (fold)
\label{par:approaches_to_concurrency}
The problems caused by concurrency are approached in a few ways. One is \textbf{isolation} where the data is partitioned in such a way that only one agent should access it at a time. Any data that is immutable can be shared without problems, but not all data is immutable. You can use \textbf{pessimistic concurrency control} where you use locks for exclusive access, this reduces liveliness, but is preferred where conflicts are frequent or have sever effects. Finally you can use \textbf{optimistic concurrency control} where you attempt to detect conflicts (bu having a version marker to dtect inconsistent reads) to improve liveliness but may result in complex merges or lost data.

When a deadlock occurs you can pick a victim to detect them, introduce timeouts to try an prevent it. A victim is any thread that acquires a locked resource so you can acquire all locks required at the beginning to prevent deadlocks. You could also use lock ordering to prevent deadlocks by forcing an order. Usually we want to use the simplest deadlock recovery/prevention schemes.
% paragraph approaches_to_concurrency (end)

\paragraph{Transactions} % (fold)
\label{par:transactions}
ACID properties:
\begin{itemize}
    \item Atomicity - each step in transition must complete fully or roll back all the way
    \item Consistency - a system's resource must be in consistent non-corrupt state at start and end of completion
    \item Isolation - the result of a transaction must not affect any other transactions until concludes successfully
    \item Durability - any completed transaction must be permanent (must survive a crash)
\end{itemize}
% paragraph transactions (end)

Transaction issues:
\begin{itemize}
    \item long transaction - spans multiple requests
    \item request transaction - spans one request, declare a method as transaction
    \item keep transactions as short as possible - no longer than 1 request so use offline concurrency to handle ones that span multiple
    \item late transactions - all updates in a short system transaction at end of business transaction
    \item lock escalation - when a query affects many records in table the DB and it locks rows to the table
\end{itemize}

\paragraph{Online locking} % (fold)
\label{par:online_locking}
Online locking is resource intensive since system transactions are connection oriented and the application needs to keep database connections open to locks. This means that connections are a scarce resource and locking them can make it worse. System transactions are ok to be used as business transactions for up to 10 users, past that you need to keep system transactions short to have higher performance.
% paragraph online_locking (end)
\paragraph{Unit of Work} % (fold)
\label{par:unit_of_work}
Here we maintain a list of objects affected by a business transaction, coordinates of writing out, and the resolution of concurrency problems. We keep track of objects that were created, changed, read, or deleted during a business transaction. The UoW marks the end of a transaction by calling \textbf{commit} which opens a system transaction, checks for inconsistent reads, writes changes to database, and commits the system transaction. This has to be kept in session state (one per session).

Implementation alternatives for UoW:
\begin{itemize}
    \item caller registration - have the caller register that an object was mucked with, this puts burden on the user of objects
    \item object registration - the receiver object registers itself, so the implementers of persistent classes need to place registration calls (good for OO)
    \item unit of work controller - takes a copy at read time from database and compares with object at commit time, this allows selective updates on only changed fields
\end{itemize}
% paragraph unit_of_work (end)

Advantages of UoW:
\begin{itemize}
    \item improve performance by deferring updates to end of business transaction (store cumulative updates)
    \item batch update optimization - bundle updates into a single unit, single remote call
    \item updates are ordered for referential integrity
    \item same sequence of updates reduces chance of deadlock
\end{itemize}

Alternatives:
\begin{itemize}
    \item single system transaction with a save on each update - this has poor performance but may be ok on smaller systems
    \item defer updates to end by keeping track of changed objects in variables
    \item keep a dirty flag on each object - basically a ghetto UoW
\end{itemize}

\paragraph{Optimistic Offline Lock} % (fold)
\label{par:optimistic_offline_lock}
Here we allow conflicts to happen and just roll back one of the transactions that caused it. This works well for systems where business transactions span multiple system transactions (so basically all of them). This also prevents lost updates and inconsistent reads as we just let shit collide and fix it later. It works by checking that, since the last time the session loaded a record no other session has changed it (basically looking for threads trampling each other) for each member of the change set during the system transaction update. One way to implement this is to give each record a version number that we compare with the last time we looked here and increment on success. When a fail happens we roll back and try to resolve it by partial discard or merge.
% paragraph optimistic_offline_lock (end)

\paragraph{Pessimistic Offline Lock} % (fold)
\label{par:pessimistic_offline_lock}
Here we prevent conflicts between transactions by allowing only one of them to access data at a time. This works by determining what type of lock is needed (read vs write since write requires no others to enter but read allows it). From this we create a lock manager that has a table mapping locks to owners and an api for business transactions that uses locks. The api operations take a session id and object id, acquire the lock, then do some shit.
% paragraph pessimistic_offline_lock (end)

We also have \textbf{coarse-grained locks} that locka  set of related objects with a single lock, and \textbf{implicit locks} that are locks implemented by the infrastructure for you.

Offline locking is nice and lighweight when compared to online locking. It is also \textbf{connection-less} so we dont need to keep a database connection for transactions. Offline locking is much more custimizable since we can add status columns or flags and whatnot. This also makes it much easier to filer and use for different resource types.
% subsection data_centric_architectures (end)

\subsection*{Blackboard Architecture} % (fold)
\label{sub:blackboard_architecture}
This is an architecture in which agents collaborate to solve a single problem on a blackboard that stores the current solution state and triggers processing on agents.

Benefits:
\begin{itemize}
    \item cooperative problem solving
    \item dynamic reconfiguratbility
    \item extensibility
\end{itemize}

Drawbacks:
\begin{itemize}
    \item complex interaction result in unpredictablity
    \item hard to debug for above reason
    \item high complexity of blackboard
\end{itemize}
% subsection blackboard_architecture (end)
% section lecture_12 (end)
\section*{Lecture 13} % (fold)
\label{sec:lecture_13}
These are systems where the availability of data controls the computation (not all data is available immediately), the pattern of data flow is explicit, and data flow is the only form of communication between components.

\begin{itemize}
    \item Components
    \begin{itemize}
        \item input ports to read
        \item output ports to write
        \item computational model to do shit inbetween
    \end{itemize}
    \item connectors: streams
    \begin{itemize}
        \item un-directional streams
        \item synchronous or async
        \item buffered or unbuffered
    \end{itemize}
\end{itemize}

There are three different topologies of data flow:
\begin{itemize}
    \item arbitrary graph
    \item linear data flow
    \item cyclic patterns (ones with loops)
\end{itemize}

\subsection*{Batch Control Architectures} % (fold)
\label{sub:batch_control_architectures}
Components are independent programs. connectors are some type of storage, and each step runs completely to success before next one can start. Basically data is grouped into batches that go through each component one at a time. This is used when data needs to be analyzed in a batch oriented fashion or when you have discrete transactions that occur at periodic intervals (like a system report every five minutes or so)
% subsection batch_control_architectures (end)

\subsection*{Pipe and Filter} % (fold)
\label{sub:pipe_and_filter}
The components are filters that process data incrementally as it arrives, the connectors are pipes or conduits (many be sync or not, buffered or not). These systems have outputs that begin before the whole input has been consumed (ex, image processing or any sort of streaming). We can either use pull or push architecture to either write data onto the next pipe or read from the previous pipe. Even better we can make pipes concurrent for processing.

\paragraph{Synchronous data flow} % (fold)
\label{par:synchronous_data_flow}
Each filter expects a certain amount of input and outputs a certain amount by passing the input through a bunch of filters sequentially (usually a line of a bunch of boxes with cardinalities). This allows for checking for balanced execution for scheduling or deadlock checking. We could also have dynamic data flow by conditional firing or Khan process networks that have actors to execute concurrent read/write tokens.
% paragraph synchronous_data_flow (end)

Strengths of pipes:
\begin{itemize}
    \item easy to understand - explicit process with simple diagrams
    \item loose coupling - only data coupling
    \item reuse - order and type doesnt really matter and filters can easily be shared
    \item extensibility - super easy to add new filters
    \item amenable to automated analysis - really easy to check for deadlocks and performance analysis as each input and output has expected attributes
    \item amenable to parallelization - each filter can be its own thread
\end{itemize}

Weaknesses of pipes:
\begin{itemize}
    \item restrictive - not all problems fit, for instance it cannot be repose time oriented or fit interactive applications (data flows one way)
    \item performance issues - filters that do little analysis still require a full copy of the data (pass by reference)
    \item implementation may force lowest common denominator data type - more complex data types will get spliced when moving between filters
    \item error handling - filters crashing can take out the whole pipe
\end{itemize}
% subsection pipe_and_filter (end)

% section lecture_13 (end)


\section*{Lecture 14} % (fold)
\label{sec:lecture_14}
\subsection*{Process Control Architectures} % (fold)
\label{sub:process_control_architectures}
Process control architecture is used to control physical processes and equipment (usually to maintain certain properties or equilibrium). Feedback is when you pipe the output of a system back into the input to stabilize it (see the entire course you're taking on it).

There are multiple kinds of variables:
\begin{itemize}
    \item control variable - basically the output we want to control
    \item manipulated variable - the input variable that we can fuck with
    \item input/confounding variable - input variables that we cannot control
    \item set point - the value we want the output to be
\end{itemize}

\textbf{Hybrid controllers} model both continuous and discrete behavior by toggling between controllers (usually via a state machine).

\textbf{Multi-variable controllers} have multiple outputs and feedback loops (ahhhhh whyyyy).

\textbf{Model-predicitve controllers} attempt to predict the output to try to increase performance (uber complex caclucations going down here).

% subsection process_control_architectures (end)
% section lecture_14 (end)

\section*{Lecture 15} % (fold)
\label{sec:lecture_15}
\subsection*{Multiple Architectural Views} % (fold)
\label{sub:multiple_architectural_views}
Each view focuses on a different perspective (for different stakeholders) and allows answering questions. We can use these for code generation or documentation so that people can get what the fuck you're trying to do. We document architecture to provide sequential reading order and make sharing much easier. Software architecture has four componenets
\begin{itemize}
    \item software requirements - what it has to do
    \item logical software architecture - how to do it
    \item physical software architecture
    \item views - link things for system testing
\end{itemize}
Uses:
\begin{itemize}
    \item  Communication
    \item Planning
    \item Requirements elicitation guidance
    \item Analysis and design guidance
    \item Reuse support
    \item Certification
\end{itemize}
% subsection multiple_architectural_views (end)
% section lecture_15 (end)

\section*{Lecture 16} % (fold)
\label{sec:lecture_16}
No lecture, just one big example.
% section lecture_16 (end)

\section*{Lecture 17} % (fold)
\label{sec:lecture_17}

% section lecture_17 (end)

\section*{Lecture 18} % (fold)
\label{sec:lecture_18}
\paragraph{Architectural Notations} % (fold)
\label{par:architectural_notations}
These can be informal such as simple lines and boxes as a quick sketch requiring no tool, or can be very formal using precise notation using tools based analysis to generate tests and skeletons.
% paragraph architectural_notations (end)

\paragraph{UML} % (fold)
\label{par:uml}
This is mostly used for architecture modeling. You need case diagrams to represent the context model and functionalities, class diagrams to represent domain models, and sequence/state/activity diagrams to represent behavior. Case diagrams show actors (the various types of users, human or otherwise) and the actions they will take with cardinalities. We can also break it up into use cases representing the series of actions that happen when an actor does something. A class diagram is the standard UML you are used to. A sequence diagram shows the timing of function calls and returns for specific actions. A state diagram shows the transitions between states, their triggers, and timing. An activity diagram show the workflow of actions
% paragraph uml (end)

\begin{itemize}
    \item Class diagrams - component types and their connections, shows architecture logical structure
    \item State diagrams - component states and transitions, show logical behavior
    \item Activity diagrams - flow of actions in components, show logical behavior
    \item Sequence diagrams - interactions among components, shows logical behavior
    \item Component diagrams - rarely used, shows physical structure
    \item Deployment diagrams - mapping of software artifacts to hardware nodes
\end{itemize}


\paragraph{SysML} % (fold)
\label{par:sysml}
This is an extension of UML for systems and software architecture. We try to represent all aspects of the system including hardware. It adds a requirements diagram that shows what components require other components.
% paragraph sysml (end)

\paragraph{Block Diagrams} % (fold)
\label{par:block_diagrams}
Block definition diagrams represent the structural elements and their composition/classification. We use these to show the domain model (basically a UML class diagram). Internal block diagrams show interfaces among parts (nested blocks). We use it to show connections among the Components
% paragraph block_diagrams (end)

Parametric diagrams are added in SysML to represent constraints on values to support analysis. Package diagrams are also added in UML ti represent model organization and show name spaces

\paragraph{AADL} % (fold)
\label{par:aadl}
This stands for architectural analysis and description language. It focuses on modeling software and hardware components and their connections. Components also include behavior components (like state and transitions between them). Lots of quality attributes are included in components like timing and performance information.
% paragraph aadl (end)

% section lecture_18 (end)

\section*{Lecture 19} % (fold)
\label{sec:lecture_19}
What is performance? The amount of usefull work that can be accomplished by a computer compared to time and resources used.

\begin{itemize}
    \item Response time - amount of time to process a request from the outside
    \item responsiveness - how quickly the system acknowledges a request
    \item Latency - minimum time required to get any form of response
    \item Throughput - how much stuff you can do in the given time (usually in transactions per second)
    \item Load - how much stress a system is under
    \item Load sensistivity - how the response time varies with the load
    \item Efficiency - performance divided by resources
    \item Capacity - maximum effective throughput or load
    \item Scalability - how adding resources affects performance
    \begin{itemize}
        \item vertical - adding more power to a single server
        \item horizontal - adding more servers
    \end{itemize}
\end{itemize}464
% section lecture_19 (end)

\section*{Lecture 20} % (fold)
\label{sec:lecture_20}
Performance can be a part of the requirements, or even part of the design criteria.

You can evaluate by defining section of the system for a specific scenario:
\begin{itemize}
    \item stimulus
    \item source
    \item environment
    \item artifact
    \item target
\end{itemize}

When anaylyzing performance we need a goal for the analysis and a subject to analyze (basically whatever the design is at the time, could be just a sketch). We can also analyze it based on the specifications by getting experts to look at it, model it, or simulate it. Further we could straight up look at the code and run performance tests or run static analysis.

\paragraph{Queuing Network Models} % (fold)
\label{par:queuing_network_models}
Anywhere in the system that queuing happen we abstract it to this model. This allows us to better understand the analysis of concurrent systems. We use \textbf{Little's Law} which says that the number of users at a node in the queuing network model is equal to the throughput at that node times the response time at that node. The number of concurrent uses is equal to the number of active users times the system response time divided by response time plush think time.

\begin{align*}
    N_i &= X_i \times R_i\\
    N_{concurrent} &= N_{active}\times \frac{R}{R+T}
\end{align*}

% paragraph queuing_network_models (end)


% section lecture_20 (end)

\section*{Lecture 21} % (fold)
\label{sec:lecture_21}
Performance is impacted by resource consumption and blocked time.

Some tricks:
\begin{itemize}
    \item control your resource demand to reduce latency
    \item manage resources to reduce response time
\end{itemize}
% section lecture_21 (end)

\section*{Lecture 22} % (fold)
\label{sec:lecture_22}
\textbf{Reliability} is the ability of a system or component to do its job. Basically not failing in a specific environment. Since failure is a random phenomenon we view reliability as a probability, using statistics as Mean time to failure, failure rate, and probability of success.

\textbf{Availability} is the probability that the system will be available when needed. It is the mean time to failure over the time to failure plus repair time.

\textbf{Safety} is the condition of being protected from harmful conditions or events (ie the software does not cause the harmful conditions). This is not the same as reliability. Unreliable systems can be safe and unsafe systems can be unreliable.

Reliability engineering focuses on the cost of removing all failures verses the cost of dealing with them. Safety engineering is focues on preventing harmful conditions. Reliability is a property of a component and safety is a system level quality.

\textbf{Failure} is when the system no longer delivers its service correctly, A failure is caused by a \textbf{fault} (not all faults cause failures). A fault is in the system and a failure is what you see as a result (sometimes, recovery is possible). An \textbf{error} is a incorrect state due to a fault.
% section lecture_22 (end)

\section{Lecture 23} % (fold)
\label{sec:lecture_23}
We define reliability scenarios such as a function must not be down for more than an hour a week or other aspects such as:
\begin{itemize}
    \item stimulus: bad value or timing
    \item source: external system, component, network, etc
    \item artifact: system or component
    \item response: notification, recovery, failure
    \item metric: availability, MTTF, etc
\end{itemize}

\textbf{Failure mode and effects analysis} is a method of analysis that works by identifying the failure modes per function or component and their effects and probabilities. This is a bottom up method where we start with components and work up to the full system. This is a more systematic method of analyzing failures, but it falls apart when there are multiple failures.

\textbf{Fault tree analysis} is a top down decomposition of system level failure into events that trigger it.

Reliability relies on multipe methods of verification:
\begin{itemize}
    \item testing - cannot prove there are no faults
    \item static analysis - checks only for certain classes of bugs
    \item model checking - exhaustive but limited by state explosion
    \item deductive program verification - generates proof obligations and proves them
\end{itemize}

Its impossible to get rid of all bugs so we aim for fault tolerance:
\begin{itemize}
    \item Error detection
    \item error handling - prevent propagation
    \item error recovery - redundancy
    \item fault prevention and removal - keep things simple and verify everything
\end{itemize}




% section lecture_23 (end)













\end{document}
