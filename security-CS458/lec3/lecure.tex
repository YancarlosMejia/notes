\documentclass{article}
\usepackage{parskip}
\usepackage{pdfpages}
\usepackage[margin=.6in]{geometry}

\begin{document}
We skipped a bunch of stuff cause its review of cs350. 


\includepdf[page=20]{Module3.pdf}
\textbf{Check every access} We want the OS to check everytime you try to access or it might notice that access had been revoked from you. Cause you're a dick.

\textbf{Enforcce least privilige} dont give people rights they dont need

\textbf{Verify acceptable use} limit the kinds of things people can do on objects

\includepdf[page=21-22]{Module3.pdf}
Most access control systems are visualized as a matrix (not implemented as one). Objects are things you want access to, Subjects are things trying to get access, and Rights are the things the subjects want to do to the object. 

\includepdf[page=23]{Module3.pdf}
Iterating over the huge access control matrix is super inefficient because it tends to be a very sparse table. Instead we tend to work by columns or rows.

\includepdf[page=24]{Module3.pdf}
ACLs are what the UNIX system uses (chmod that shit). These are column wise interpretation of an access matrix.

\begin{itemize}
	\item o = owner
	\item g = group
	\item w = world
\end{itemize}

Looking at these ACLs:
\begin{itemize}
	\item we can easily find who is allowed to access an object: its very quick because this data is stored on the object
	\item we cannot easily find all objects a user can access: we'd have to go through all objects and check if the user can access it
	\item we can easily revoke access to a single object but stupid for all because you have to go through all of them
\end{itemize}

\includepdf[page=25]{Module3.pdf}
Capabilities are when we assign rights on a user basis (a row wise look at access matrix). Security for this is very hard because we have to have a list of rights stored somewhere. You have to maintain that when a user access it they don't fuck it up and have permission to look at it. This list can be stored on the OS or on the user, we prefer storing it on the OS. If we give a digital signature to a user (letting them store their own rights) you have to ask them for their capabilities whenever they want access. If a user is not contactable then we cannot know anything about them. It also makes it very hard to revoke their access because they can just refuse to give over their token.
 
\includepdf[page=26]{Module3.pdf}
Most systems use a combination of the two primarily for performance reasons. In linux rights are originally stored as acls but when you open a file they get converted into capabilities (for example fopen returns a file descriptor that tells you its rights).

\includepdf[page=27]{Module3.pdf}
We like to clump users into groups called roles. Everyone in a role has the same access. This makes it very easy to update someones rights by just moving them to a new group. Most comercial databases use this model.

\includepdf[page=28]{Module3.pdf}

\includepdf[page=30]{Module3.pdf}
AUTHENTICATE EVERYTHING, yep thats pretty much it.

\textbf{Identification} is asking who someone is. \textbf{Authentication} is checking that you actually are who you say you are (make sure you have the rights you claim).

\includepdf[page=32]{Module3.pdf}
We can use what a user knows (some data they would know), what they have (an object they have like cookie or atm card), something about what the user is (like biometrics), and something about the user's context (like are they at home now).

\includepdf[page=33]{Module3.pdf}
Good security usually looks to have multiple factors of authentication usually from different classes. With physical items we need to watch for them just becoming data. 

\includepdf[page=34-35]{Module3.pdf}
USE A PASSWORD MANAGER. That is all.

\includepdf[page=36-37]{Module3.pdf}
We want very long passwords to make brute force attacks much harder.

\includepdf[page=38]{Module3.pdf}
People use patterns and other methods to remember their passwords which can be leveraged to guess them. Software that does this often looks at common password leaks to spot patterns. You want to be able to tell when there is a breach. The most important thing is the throttle login attempts (don't let the same user try to login a ton of times). The iCloud login attack (that got celebrity pics) happened because an api call was not throttled.

\includepdf[page=40]{Module3.pdf}
\includepdf[page=42]{Module3.pdf}
\includepdf[page=44-46]{Module3.pdf}
We do not what to store our passwords in plain text. We should hash them on the way in. Basically we want to make is so that you cannot figure out the password based on the username. Currently everyone uses sha2 hashing but we are soon going to switch to sha3. There are someplaces that store precomputed lists of hashes to help you attack faster (often called rainbow tables).

\includepdf[page=47]{Module3.pdf}
We should be salting our hashes. Generate a random string and pad the hash with it. It should be unique for each user, quite long (48-128 bits) and very random. This helps stop people from precomputing them. Frequently hackers will know the salt, but it still stops rainbow table attacks. 

\includepdf[page=48]{Module3.pdf}
You could also delay a while when calculating the hash so that brute force attacks become way more expensive. Basically you just iterate over hashing the hash a bunch of times. 

\includepdf[page=49]{Module3.pdf}
MAC is message authentication code (often based on hashes making then HMACs). The key difference is that MACs have keys that are required to create a MAC and to verify data. Hashes are just functions. 

\includepdf[page=50-51]{Module3.pdf}
You can pepper your password by putting in a special bit of hardware called a hardware security module. This is very hard to get into. This won't ever give out a password, it will MAC something for you and just return that. This will prevent attacks even if they have your code base and know how you hash stuff. Even if they were to get the key to your HSM its still as secure as using an iterative hash. Some laptops have TMPs that can work as very specific HSMs (they have the key burned into them at time of manufacturing). 

\includepdf[page=52-53]{Module3.pdf}
If a password is the same it will encrypt the same. And it encrypts in chunks so you can figure out what the encryption key is looking at it. Its little more secure than a slightly challenging puzzle.

\includepdf[page=55]{Module3.pdf}
You password still has to be sent through the network, this can be a vulnerability in itself. You have to encrypt the link between you and the server or anyone who is watching can just see it as it goes through. Another attack is if the server gets compromised. If they get read access thats ok because everything is hashed, but if they get write access they can catch the plaintext password and do what they want with it. You can defend agains this by having the server send a challenge that is different every time, the client uses that to create a one time password, then the server replys with a response. Anyone listening will not know what is going on there. 

There are some cool ideas where you store passwords on your phone (fido and sqrl) where the website shows a QR code which your phone uses as a challenge to log in.






\end{document}